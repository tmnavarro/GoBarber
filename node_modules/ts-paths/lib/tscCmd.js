"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path_1 = require("path");
const shell = require("shelljs");
const fs_extra_1 = require("fs-extra");
const logger_1 = require("./logger");
const decorator_1 = require("./decorator");
const utils_1 = require("./utils");
class TscCmd {
    constructor(props) {
        this.logger.debug = props.debug;
        this.logger.level = props.level || 2;
    }
    async build(opt = {}) {
        const tsconfigName = opt.tsconfigName || this._tsconfigName;
        const projectPath = path_1.resolve(opt.rootDir, opt.projectPath || this._projectPath);
        const tsconfigPath = path_1.join(projectPath, tsconfigName);
        let isTsFile = await utils_1.isFile(tsconfigPath);
        if (!isTsFile) {
            return this.logger.error("tsconfigName 必须是个单文件");
        }
        let isProject = await utils_1.isDirectory(projectPath);
        if (!isProject) {
            return this.logger.error("projectPath 必须是一个文件夹");
        }
        this.logger.info(`编译文件夹绝对路径 => ${projectPath}`);
        this.logger.info(`tsconfig.json 文件路径 => ${tsconfigPath}`);
        let compilerOptions = await utils_1.filesToJson(tsconfigPath, [
            "compilerOptions"
        ]);
        await this._buildTsc(tsconfigPath);
        let tsconfigDir = path_1.dirname(tsconfigPath);
        let baseUrl = compilerOptions.baseUrl;
        let pathsJson = compilerOptions.paths;
        let outDir = compilerOptions.outDir;
        let pathsConfig = this._queryPathsConfig(path_1.join(tsconfigDir, outDir, baseUrl), pathsJson);
        let targetRootDir = compilerOptions.rootDir;
        await this._transformPaths(path_1.join(tsconfigDir, targetRootDir), path_1.join(tsconfigDir, outDir), pathsConfig);
    }
    _queryPathsConfig(baseUrl, pathsJson) {
        let pathsConfig = {};
        Object.keys(pathsJson).forEach(key => {
            pathsConfig[key] = path_1.join(baseUrl, pathsJson[key][0]);
        });
        return pathsConfig;
    }
    async _buildTsc(tsconfigPath) {
        this.logger.info("开始编译文件");
        let cmd = `tsc --project ${tsconfigPath}`;
        this.logger.info(`exec: ${cmd}`);
        shell.exec(cmd);
        if (shell.error()) {
            this.logger.error("编译失败");
            process.exit(-1);
        }
    }
    async _transformPaths(rootDir, outDir, pathsConfig) {
        console.log("pathsConfig", pathsConfig);
        this.logger.info("开始替换文件字符");
        this.logger.info(`ts配置文件指向目录 => ${rootDir}`);
        this.logger.info(`ts配置文件输出目录 => ${outDir}`);
        const includesExtname = [".ts", ".js"];
        let foreachDir = targetPath => {
            let pa = fs_extra_1.readdirSync(targetPath);
            pa.forEach(async (item) => {
                let itemPath = path_1.join(targetPath, item);
                if (await utils_1.isDirectory(itemPath)) {
                    foreachDir(itemPath);
                }
                else {
                    if (includesExtname.includes(path_1.extname(itemPath))) {
                        this.logger.warn(`目标文件 => ${itemPath}`);
                        let file = fs_extra_1.readFileSync(itemPath).toString();
                        Object.keys(pathsConfig).forEach(targetPath => {
                            if (file.indexOf(targetPath) != -1) {
                                let relative_path = path_1.relative(path_1.dirname(itemPath), pathsConfig[targetPath]);
                                this.logger.info(`targetPath => ${targetPath}`);
                                this.logger.info(`relative_path => ${relative_path}`);
                                file = file.replace(targetPath, relative_path);
                            }
                        });
                        fs_extra_1.writeFileSync(itemPath, file);
                    }
                }
            });
        };
        foreachDir(outDir);
    }
}
tslib_1.__decorate([
    decorator_1.Autowired(),
    tslib_1.__metadata("design:type", logger_1.Logger)
], TscCmd.prototype, "logger", void 0);
tslib_1.__decorate([
    decorator_1.Value("tsconfig.json"),
    tslib_1.__metadata("design:type", String)
], TscCmd.prototype, "_tsconfigName", void 0);
tslib_1.__decorate([
    decorator_1.Value("./"),
    tslib_1.__metadata("design:type", String)
], TscCmd.prototype, "_projectPath", void 0);
exports.TscCmd = TscCmd;
//# sourceMappingURL=tscCmd.js.map